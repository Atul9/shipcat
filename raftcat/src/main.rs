#![allow(unused_imports, unused_variables)]

extern crate url;
extern crate http;
#[macro_use]
extern crate serde;
extern crate serde_json;
#[macro_use] extern crate failure;
#[macro_use]
extern crate serde_derive;
extern crate kubernetes;
extern crate shipcat_definitions;

extern crate env_logger;
extern crate actix;
extern crate actix_web;

use failure::{Error, Fail};

use shipcat_definitions::{Crd, CrdList, Manifest};



//#[derive(Debug)]
//struct AppError(failure::Error);
//
//impl<T: Into<failure::Error>> From<T> for AppError {
//    fn from(t: T) -> AppError { AppError(t.into()) }
//}
//type Result<T> = std::result::Result<T, AppError>;
type Result<T> = std::result::Result<T, Error>;

// api maps (needs to be autogenerated by kube normally anyway..)
fn make_all_crd_entry_req(resource: &str, group: &str) -> Result<http::Request<Vec<u8>>> {
    let urlstr = format!("/apis/{group}/v1/{resource}?", group = group, resource = resource);
    let mut qp = url::form_urlencoded::Serializer::new(urlstr);
    let urlstr = qp.finish();
    let mut req = http::Request::get(urlstr);
    req.body(vec![]).map_err(Error::from)
}

fn make_crd_entry_req(resource: &str, group: &str, name: &str) -> Result<http::Request<Vec<u8>>> {
    // TODO: namespace from evar
    let urlstr = format!("/apis/{group}/v1/namespaces/dev/{resource}/{name}?",
        group = group, resource = resource, name = name);
    let urlstr = url::form_urlencoded::Serializer::new(urlstr).finish();
    let mut req = http::Request::get(urlstr);
    req.body(vec![]).map_err(Error::from)
}

/*fn watch_crd_entry_after(resource: &str, group: &str, name: &str, rver: u32) -> Result<http::Request<Vec<u8>>> {
    let urlstr = format!("/apis/{group}/v1/namespaces/dev/{resource}/{name}?",
        group = group, resource = resource, name = name);
    let mut qp = url::form_urlencoded::Serializer::new(urlstr);

    qp.append_pair("timeoutSeconds", "30");
    qp.append_pair("watch", "true");

    // last version to watch after
    //qp.append_pair("resourceVersion", &rver.to_string());

    let urlstr = qp.finish();
    let mut req = http::Request::get(urlstr);
    req.body(vec![]).map_err(Error::from)
}*/
static GROUPNAME: &str = "babylontech.co.uk";
static SHIPCATRESOURCE: &str = "shipcatmanifests";

// program interface
pub fn get_shipcat_manifests(client: &APIClient) -> Result<Vec<Crd<Manifest>>> {
    let req = make_all_crd_entry_req(SHIPCATRESOURCE, GROUPNAME)?;
    let res = client.request::<CrdList<_>>(req)?;
    /*for i in &res.items {
        let mf : &Manifest = &i.spec;
        println!("{}", mf.name);
    }*/
    Ok(res.items)
}

/*
this doesn't actually work...
pub fn watch_shipcat_manifest(client: &APIClient, name: &str, rver: u32) -> Result<Crd<Manifest>> {
    let req = watch_crd_entry_after(SHIPCATRESOURCE, GROUPNAME, name, rver)
        .expect("failed to define crd watch request");
    let res = client.request::<Crd<_>>(req)?;
    {
        let mf : &Manifest = &res.spec;
        println!("{}", mf.name);
    }
    Ok(res)
}*/

pub fn get_shipcat_manifest(client: &APIClient, name: &str) -> Result<Crd<Manifest>> {
    let req = make_crd_entry_req(SHIPCATRESOURCE, GROUPNAME, name)?;
    let res = client.request::<Crd<_>>(req)?;
    /*{
        let mf : &Manifest = &res.spec;
        println!("{}", mf.name);
    }*/
    // TODO: merge with version found in rolling env?
    Ok(res)
}



use serde::de::DeserializeOwned;
use kubernetes::config;
use kubernetes::config::Configuration;

//use kubernetes::client::APIClient;
// Fork APIClient in kubernetes temporarily because deserialize screws up...
pub struct APIClient {
    configuration: Configuration,
}
impl APIClient {
    pub fn new(configuration: Configuration) -> Self {
        APIClient { configuration }
    }

    /// Returns kubernetes resources binded `Arnavion/k8s-openapi-codegen` APIs.
    pub fn request<T>(&self, request: http::Request<Vec<u8>>) -> Result<T>
    where
        T: DeserializeOwned,
    {
        let (parts, body) = request.into_parts();
        let uri_str = format!("{}{}", self.configuration.base_path, parts.uri);
        let req = match parts.method {
            http::Method::GET => self.configuration.client.get(&uri_str),
            http::Method::POST => self.configuration.client.post(&uri_str),
            http::Method::DELETE => self.configuration.client.delete(&uri_str),
            http::Method::PUT => self.configuration.client.put(&uri_str),
            other => {
                return Err(Error::from(format_err!("Invalid method: {}", other)));
            }
        }.body(body);

        let mut res = req.send()?;
        let text = res.text()?;
        //println!("got text: {}", text);
        serde_json::from_str(&text).map_err(Error::from)
        //res.json().map_err(Error::from)
    }
}

// Share kube client between http requests
use std::sync::{Arc, Mutex};
struct AppState {
    client: Arc<Mutex<APIClient>>,
}

use actix_web::{server, App, Path, Responder, HttpRequest, HttpResponse, middleware};
use actix_web::http::{header, Method, StatusCode};

fn actix_get_manifest(req: &HttpRequest<AppState>) -> HttpResponse {
    //println!("{:?}", req);
    let name = req.match_info().get("name").unwrap();
    let client = req.state().client.lock().unwrap();
    let mf = get_shipcat_manifest(&client, name).unwrap();

    //let mf = req.state().manifests.lock().unwrap();
    //HttpResponse::Ok().body(format!("Num of requests: {}", mf[0].spec.name))

    HttpResponse::Ok().json(mf)
}

fn actix_get_manifests(req: &HttpRequest<AppState>) -> HttpResponse {
    let client = req.state().client.lock().unwrap();
    let mfs = get_shipcat_manifests(&client).unwrap();
    HttpResponse::Ok().json(mfs)
}

fn main() -> Result<()> {
    std::env::set_var("RUST_LOG", "actix_web=debug");
    std::env::set_var("RUST_BACKTRACE", "1");
    env_logger::init();
    let sys = actix::System::new("raftcat");

    server::new(move || {
        // Load the config: local kube config prioritised first for local development
        // NB: Only supports a config with client certs locally (e.g. kops setup)
        let cfg = config::load_kube_config().unwrap_or_else(|_| {
            config::incluster_config().expect("in cluster config failed to load")
        });
        let client = APIClient::new(cfg);
        let state = AppState { client: Arc::new(Mutex::new(client)) };
        App::with_state(state)
            .middleware(middleware::Logger::default())
            .resource("/manifests/{name}", |r| r.method(Method::GET).f(actix_get_manifest))
            .resource("/manifests/", |r| r.method(Method::GET).f(actix_get_manifests))
        })
        .bind("127.0.0.1:8080").expect("Can not bind to 127.0.0.1:8080")
        .shutdown_timeout(0)    // <- Set shutdown timeout to 0 seconds (default 60s)
        .start();

    println!("Starting http server: 127.0.0.1:8080");
    let _ = sys.run();
    unreachable!();
}
