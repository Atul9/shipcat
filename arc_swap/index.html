<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `arc_swap` crate."><meta name="keywords" content="rust, rustlang, rust-lang, arc_swap"><title>arc_swap - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Crate arc_swap</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'arc_swap', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/arc_swap/lib.rs.html#1-1558' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>arc_swap</a></span></h1><div class='docblock'><p>Making <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> itself atomic</p>
<p>The <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> uses atomic reference counters, so the object behind it can be safely pointed to by
several threads at once. However, the <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> itself is quite ordinary ‒ to change its value
(make it point somewhere else), one has to be the sole owner of it (or store it behind a
<a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>).</p>
<p>On the other hand, there's <a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicPtr.html"><code>AtomicPtr</code></a>. It can be modified and read from multiple threads,
allowing to pass the value from one thread to another without the use of a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>. The
downside is, tracking when the data can be safely deleted is hard.</p>
<p>This library provides <a href="type.ArcSwap.html"><code>ArcSwap</code></a> that allows both at once. It can be
constructed from ordinary <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>, but its value can be loaded and stored atomically, by
multiple concurrent threads.</p>
<h1 id="motivation" class="section-header"><a href="#motivation">Motivation</a></h1>
<p>For one, the C++ <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><code>shared_ptr</code></a> has this
<a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/atomic">ability</a>, so it is only fair to
have it too.</p>
<p>For another, it seemed like a really good exercise.</p>
<p>And finally, there are some real use cases for this functionality. For example, when one thread
publishes something (for example configuration) and other threads want to have a peek to the
current one from time to time. There's a global <a href="type.ArcSwap.html"><code>ArcSwap</code></a>, holding the
current snapshot and everyone is free to make a copy and hold onto it for a while. The
publisher thread simply stores a new snapshot every time and the old configuration gets dropped
once all the other threads give up their copies of the pointer.</p>
<h1 id="performance-characteristics" class="section-header"><a href="#performance-characteristics">Performance characteristics</a></h1>
<p>The data structure is optimised for read-heavy situations with only occasional writes.</p>
<p>Only very basic benchmarks were done so far (you can find them in the git repository). These
suggest reading operations are faster than using a mutex, in a contended situation by a large
margin, but about 2-3 times slower on writes than mutex (it is still faster than <code>RwLock</code> on
writes and mutex gets much slower on contended writes).</p>
<p>Furthermore, this implementation doesn't suffer from contention. Specifically, arbitrary number
of readers can access the shared value and won't block each other, and are not blocked by
writers. The writers will be somewhat slower when there are active readers at the same time,
but won't be stopped indefinitely. Readers always perform the same number of instructions,
without any locking or waiting, with the exception of the first
<a href="struct.ArcSwapAny.html#method.lease"><code>lease</code></a> in each thread (though they can slow each other
down by accessing the same memory locations under circumstances).</p>
<h2 id="what-reading-operation-to-choose" class="section-header"><a href="#what-reading-operation-to-choose">What reading operation to choose</a></h2>
<p>There are actually three different ways to read the data, with different characteristics.</p>
<ul>
<li><a href="struct.ArcSwapAny.html#method.load"><code>load</code></a> creates a full-blown <code>Arc</code>. You can hold onto it
as long as desired without any restrictions, but in case there are multiple readers of the
same <a href="struct.ArcSwapAny.html"><code>ArcSwapAny</code></a>, they slow each other down by fighting over the
cache line with reference counts. Therefore, this is suitable for long-term storage of the
result.</li>
<li><a href="struct.ArcSwapAny.html#method.lease"><code>lease</code></a> is suitable for short-term storage or
manipulation during some algorithm, for example
during some lookup. The creation is relatively fast and doesn't suffer from contention, but
there's only limited number of fast active leases possible per thread (currently 6). When the
number is exceeded, it falls back to the equivalent of
<a href="struct.ArcSwapAny.html#method.load"><code>load</code></a> internally.</li>
<li><a href="struct.ArcSwapAny.html#method.peek"><code>peek</code></a> is the fastest. However, existing
<a href="struct.Guard.html"><code>Guard</code></a>, as returned by the method, prevents all writer methods from
completing (globally, even on unrelated <code>ArcSwap</code>s). Therefore, it is possible to create a
deadlock with careless usage and hurt the performance by holding onto it for too long. It is
suitable for very quick operations only, like reading a single value from configuration. Do
not store it and do not call non-trivial methods on the returned value.</li>
</ul>
<p>The faster but shorter-term proxy objects allow upgrading to the longer-term ones, so it is
possible to first do some checks for an optimistic case and obtain the longer-term object in
the pesimistic case.</p>
<h1 id="rcu" class="section-header"><a href="#rcu">RCU</a></h1>
<p>This also offers an <a href="struct.ArcSwapAny.html#method.rcu">RCU implementation</a>, for read-heavy
situations. Note that the RCU update is considered relatively slow operation. In case there's
only one update thread, using <a href="struct.ArcSwapAny.html#method.store"><code>store</code></a> is enough.</p>
<h1 id="atomic-orderings" class="section-header"><a href="#atomic-orderings">Atomic orderings</a></h1>
<p>It is guaranteed each operation performs at least one <code>SeqCst</code> atomic read-write operation,
therefore even operations on different instances have a defined global order of operations.</p>
<h1 id="unix-signal-handlers" class="section-header"><a href="#unix-signal-handlers">Unix signal handlers</a></h1>
<p>Unix signals are hard to use correctly, partly because there is a very restricted set of
functions one might use inside them. Specifically, it is <em>not</em> allowed to use mutexes inside
them (because that could cause a deadlock).</p>
<p>On the other hand, it is possible to use
<a href="struct.ArcSwapAny.html#method.peek_signal_safe"><code>ArcSwap::peek_signal_safe</code></a> (but not the
others). Note that the signal handler is not allowed to allocate or deallocate
memory, therefore it is not recommended to <a href="struct.Guard.html#method.upgrade"><code>upgrade</code></a> the
returned guard (it is strictly speaking possible to use that safely, but it is hard and brings
no benefit).</p>
<h1 id="support-for-null" class="section-header"><a href="#support-for-null">Support for <code>NULL</code></a></h1>
<p>Similar to <code>Arc</code>, <a href="type.ArcSwap.html"><code>ArcSwap</code></a> always contains a value. There is, however,
<a href="type.ArcSwapOption.html"><code>ArcSwapOption</code></a>, which works on <code>Option&lt;Arc&lt;_&gt;&gt;</code> instead of
<code>Arc&lt;_&gt;</code> and supports mostly the same operations. In fact, both are just type aliases of
<a href="struct.ArcSwapAny.html"><code>ArcSwapAny</code></a>. Therefore, most documentation and methods can be found
there instead on the type aliases.</p>
<p>It is also possible to support other types similar to <code>Arc</code> by implementing the
<a href="trait.RefCnt.html"><code>RefCnt</code></a> trait.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">arc_swap</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">crossbeam_utils</span>;

<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">sync</span>::<span class="ident">Arc</span>;

<span class="kw">use</span> <span class="ident">arc_swap</span>::<span class="ident">ArcSwap</span>;
<span class="kw">use</span> <span class="ident">crossbeam_utils</span>::<span class="ident">thread</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">config</span> <span class="op">=</span> <span class="ident">ArcSwap</span>::<span class="ident">from</span>(<span class="ident">Arc</span>::<span class="ident">new</span>(<span class="ident">String</span>::<span class="ident">default</span>()));
    <span class="ident">thread</span>::<span class="ident">scope</span>(<span class="op">|</span><span class="ident">scope</span><span class="op">|</span> {
        <span class="ident">scope</span>.<span class="ident">spawn</span>(<span class="op">||</span> {
            <span class="kw">let</span> <span class="ident">new_conf</span> <span class="op">=</span> <span class="ident">Arc</span>::<span class="ident">new</span>(<span class="string">&quot;New configuration&quot;</span>.<span class="ident">to_owned</span>());
            <span class="ident">config</span>.<span class="ident">store</span>(<span class="ident">new_conf</span>);
        });
        <span class="kw">for</span> <span class="kw">_</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">10</span> {
            <span class="ident">scope</span>.<span class="ident">spawn</span>(<span class="op">||</span> {
                <span class="kw">loop</span> {
                    <span class="kw">let</span> <span class="ident">cfg</span> <span class="op">=</span> <span class="ident">config</span>.<span class="ident">lease</span>();
                    <span class="kw">if</span> <span class="op">!</span><span class="ident">cfg</span>.<span class="ident">is_empty</span>() {
                        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">cfg</span>, <span class="string">&quot;New configuration&quot;</span>);
                        <span class="kw">return</span>;
                    }
                }
            });
        }
    });
}</pre>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.ArcSwapAny.html"
                                  title='struct arc_swap::ArcSwapAny'>ArcSwapAny</a></td>
                           <td class='docblock-short'>
                                <p>An atomic storage for a smart pointer like <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> or <code>Option&lt;Arc&gt;</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Guard.html"
                                  title='struct arc_swap::Guard'>Guard</a></td>
                           <td class='docblock-short'>
                                <p>A short-term proxy object from <a href="struct.ArcSwapAny.html#method.peek"><code>peek</code></a>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="struct" href="struct.Lease.html"
                                  title='struct arc_swap::Lease'>Lease</a></td>
                           <td class='docblock-short'>
                                <p>A temporary storage of the pointer.</p>

                           </td>
                       </tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.AsRaw.html"
                                  title='trait arc_swap::AsRaw'>AsRaw</a></td>
                           <td class='docblock-short'>
                                <p>A trait describing things that can be turned into a raw pointer.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.NonNull.html"
                                  title='trait arc_swap::NonNull'>NonNull</a></td>
                           <td class='docblock-short'>
                                <p>A trait describing smart pointers that can't hold NULL.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.RefCnt.html"
                                  title='trait arc_swap::RefCnt'>RefCnt</a></td>
                           <td class='docblock-short'>
                                <p>A trait describing smart reference counted pointers.</p>

                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.ptr_eq.html"
                                  title='fn arc_swap::ptr_eq'>ptr_eq</a></td>
                           <td class='docblock-short'>
                                <p>Comparison of two pointer-like things.</p>

                           </td>
                       </tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="type" href="type.ArcSwap.html"
                                  title='type arc_swap::ArcSwap'>ArcSwap</a></td>
                           <td class='docblock-short'>
                                <p>An atomic storage for <code>Arc</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="type" href="type.ArcSwapOption.html"
                                  title='type arc_swap::ArcSwapOption'>ArcSwapOption</a></td>
                           <td class='docblock-short'>
                                <p>An atomic storage for <code>Option&lt;Arc&gt;</code>.</p>

                           </td>
                       </tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "arc_swap";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>