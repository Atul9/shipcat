use super::traits::Verify;
use super::{Result, Config};

/// ConfigMap
///
/// A special abstraction that is used to create a kubernetes ConfigMap
/// Deals with automatic mounting into the pods.
///
/// Only one of these is supported.
#[derive(Serialize, Deserialize, Clone, Default)]
#[serde(deny_unknown_fields)]
pub struct ConfigMap {
    /// Optional k8s specific name for the mount (autogenerated if left out)
    pub name: Option<String>,
    /// Container-local directory path where configs are available
    pub mount: String,
    /// Files from the config map to mount at this mountpath
    pub files: Vec<ConfigMappedFile>
}

/// ConfigMapped File
///
/// Files that are mounted under the parent `mount` path.
#[derive(Serialize, Deserialize, Clone, Default)]
#[serde(deny_unknown_fields)]
pub struct ConfigMappedFile {
    /// Name of file to template (from service repo paths)
    pub name: String,
    /// Name of file inside container
    pub dest: String,
    /// Config value inlined
    ///
    /// This is usually filled in internally by to help out Helm a bit
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}


impl Verify for ConfigMap {
    fn verify(&self, _: &Config) -> Result<()> {
        // mount paths can't be empty string
        if self.mount == "" || self.mount == "~" {
            bail!("Empty mountpath for {} mount ", self.name.clone().unwrap())
        }
        // and must end in a slash to have a standard
        if !self.mount.ends_with('/') {
            bail!("Mount path '{}' for {} must end with a slash", self.mount, self.name.clone().unwrap());
        }
        for f in &self.files {
            if !f.name.ends_with(".j2") {
                bail!("Only supporting templated config files atm")
            }
        }
        // TODO: verify file exists? done later anyway
        Ok(())
    }
}
