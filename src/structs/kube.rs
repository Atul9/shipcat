use regex::Regex;

use super::traits::Verify;
use super::Result;

/// Kubernetes resources

// HostAlias support for all pods regardless of network configuration.
#[derive(Serialize, Deserialize, Clone, Debug, Default)]
pub struct HostAlias {
    /// ip address string
    pub ip: String,
    /// add additional entries that resolve the ip address to the hosts file
    pub hostnames: Vec<String>,
}

impl Verify for HostAlias {
    //  only verify syntax
    fn verify(&self) -> Result<()> {
        // Commonly accepted hostname regex from https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address
        let ip_re = Regex::new(r"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$").unwrap();
        if self.ip == "" || !ip_re.is_match(&self.ip){
            bail!("The ip address for the host alias is incorrect");
        }
        if self.hostnames.is_empty() {
            bail!("At least one hostname must be specified for the host alias");
        }
        for hostname in &self.hostnames {
            // Commonly accepted ip address regex from https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address
            let host_re = Regex::new(r"^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$").unwrap();
            if !host_re.is_match(&hostname) {
                bail!("The hostname {} is incorrect for {}", hostname, self.ip);
            }
        }
        Ok(())
    }
}

#[derive(Serialize, Deserialize, Clone, Default)]
pub struct ConfigMappedFile {
    /// Name of file to template (from service repo paths)
    pub name: String,
    /// Name of file inside container
    pub dest: String,
    /// Config value inlined
    ///
    /// This is usually filled in internally by to help out Helm a bit
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}
#[derive(Serialize, Deserialize, Clone, Default)]
pub struct ConfigMap {
    /// Optional k8s specific name for the mount (autogenerated if left out)
    pub name: Option<String>,
    /// Container-local directory path where configs are available
    pub mount: String,
    /// Files from the config map to mount at this mountpath
    pub files: Vec<ConfigMappedFile>
}

impl Verify for ConfigMap {
    fn verify(&self) -> Result<()> {
        // mount paths can't be empty string
        if self.mount == "" || self.mount == "~" {
            bail!("Empty mountpath for {} mount ", self.name.clone().unwrap())
        }
        // and must end in a slash to have a standard
        if !self.mount.ends_with('/') {
            bail!("Mount path '{}' for {} must end with a slash", self.mount, self.name.clone().unwrap());
        }
        for f in &self.files {
            if !f.name.ends_with(".j2") {
                bail!("Only supporting templated config files atm")
            }
        }
        // TODO: verify file exists? done later anyway
        Ok(())
    }
}


#[derive(Serialize, Deserialize, Clone, Default)]
pub struct HealthCheck {
    /// Where the health check is located
    #[serde(default = "health_check_url_default")]
    pub uri: String,
    /// How long to wait after boot in seconds
    #[serde(default = "health_check_wait_time_default")]
    pub wait: u32,
}
fn health_check_url_default() -> String { "/health".into() }
fn health_check_wait_time_default() -> u32 { 30 }


#[derive(Serialize, Deserialize, Clone, Default)]
pub struct VolumeMount {
    pub name: String,
    pub mountPath: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subPath: Option<String>,
    #[serde(default = "volume_mount_read_only")]
    pub readOnly: bool,
}
fn volume_mount_read_only() -> bool { false }

#[derive(Serialize, Deserialize, Clone, Default)]
pub struct InitContainer {
    pub name: String,
    pub image: String,
    pub command: Vec<String>,
}

impl Verify for InitContainer {
    // only verify syntax
    fn verify(&self) -> Result<()> {
        let re = Regex::new(r"(?:[a-z]+/)?([a-z]+)(?::[0-9]+)?").unwrap();
        if !re.is_match(&self.image) {
            bail!("The init container {} does not seem to match a valid image registry", self.name);
        }
        if self.command.is_empty() {
            bail!("A command must be specified for the init container {}", self.name);
        }
        Ok(())
    }
}


#[derive(Serialize, Deserialize, Clone)]
pub struct VolumeSecretItem {
    #[serde(default = "volume_key")]
    pub key: String,
    pub path: String,
    #[serde(default = "volume_default_mode")]
    pub mode: u32,
}
fn volume_key() -> String { "value".into() }
fn volume_default_mode() -> u32 { 420 } // 0644

#[derive(Serialize, Deserialize, Clone, Default)]
pub struct VolumeSecretDetail {
    pub name: String,
    pub items: Vec<VolumeSecretItem>,
}

#[derive(Serialize, Deserialize, Clone, Default)]
pub struct VolumeSecret {
    pub secret: Option<VolumeSecretDetail>,
}

#[derive(Serialize, Deserialize, Clone, Default)]
pub struct ProjectedVolumeSecret {
    pub sources: Vec<VolumeSecret>,
    // pub default_mode: u32,
}

#[derive(Serialize, Deserialize, Clone, Default)]
pub struct Volume {
    pub name: String,
    /// A projection combines multiple volume items
    #[serde(skip_serializing_if = "Option::is_none")]
    pub projected: Option<ProjectedVolumeSecret>,
    /// The secret is fetched  from kube secrets and mounted as a volume
    #[serde(skip_serializing_if = "Option::is_none")]
    pub secret: Option<VolumeSecretDetail>,
}

impl Verify for Volume {
    fn verify(&self) -> Result<()> {
        // TODO: verify stuff here
        Ok(())
    }
}
